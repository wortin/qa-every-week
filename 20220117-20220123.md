# 问题

1. mysql事务隔离的底层实现
2. http的长、短连接以及应用场景
3. redis集群的原理
4. 附加题：关于kafka的全部面试点（你需要尽量了解kafka）

ps：附加题回答不满意不扣钱

# 回答

## 1. mysql事务隔离的底层实现

mysql的事务隔离分四种：


|事务隔离级别 |   脏读   |  不可重复读  |  幻读   |
|:-----:|:------:|:-------:|:-----:|
| 读未提交  |   Y    |    Y    |   Y   |
| 不可重复读 |   N    |    Y    |   Y   |
| 可重复读  |   N    |    N    |   Y   |
|  串行   |   N    |    N    |   N   |


+ 脏读：本次事务中读取到其他事务未提交的数据
+ 不可重复读：本次事务中读取到其他事务已经提交的数据，但是本次事务中再次读取和第一次读取数据不一致
+ 幻读：本地事务中多次读取数据一致，但是出现新插入的数据

Mysql的事务隔离是由存储引擎实现的（Mysql服务器不管理事务），提供了两种事务型的存储引擎：Innodb和NDB Cluster。另外第三方的存储引擎也支持事务：XtraDB、PBXT。

### MVCC 

大多数事务型存储引擎实现都不是简单的行级锁，基于并发性能考虑，一般都实现了多版本并发控制（MVCC）。
以Innodb为例，这里通过简化的MVCC行为来说明实现原理：

Innodb为每个数据行增加两个隐藏列：创建时间、过期时间，用于存储系统版本号。每开始一个新事务，系统版本号自动递增。
事务开始时，系统版本号就是该事务的事务版本号，并且对于事务中相应的执行语句做如下操作：

+ 当事务中执行SELECT语句时：
  + 查找那些创建时间<=当前事务版本号的数据行，这些数据是事务开始前已经存在或当前事务插入或修改的
  + 查找那些过期时间为空或>当前事务版本号的数据行，这些数据是事务开始前还没有被删除的
+ 当事务中执行INSERT语句时：
  + 新插入的行的创建时间设置为当前事务版本号
+ 当事务中执行DELETE语句时：
  + 被删除的行的过期时间设置为当前事务版本号
+ 当事务中执行UPDATE语句时：
  + 插入一行新数据设置其创建时间为当前事务版本号，原来数据的过期时间设置为当前事务版本号

MVCC只在不可重复读和可重复读两个事务隔离级别下工作。因为读未提交总是读取最新的数据，而MVCC只读取符合当前事务版本号的相应数据；串行会对所有读取的行加锁，而MVCC不会。

### 间隙锁

Innodb采用MVCC支持高并发，并通过间隙锁（Next-Key Locking）对索引中的间隙进行锁定，防止幻读出现。


## 2. http的长、短连接以及应用场景

### http短连接

HTTP1.0默认使用短连接。

http客户端和服务端每进行一次HTTP交互，就建立一次连接，任务结束就中断连接。

短连接使用场景：
+ 随机的即时的请求
+ 请求数量多
+ 对资源有限制而希望通过短连接减少长连接的连接数耗费的资源

### http长连接。

HTTP1.1起默认使用长连接。

http客户端和服务端进行HTTP交互只需建立一次连接，并在响应头带上"Connection:keep-alive"表示保持连接而不关闭。
如果客户端再次请求，会继续使用该连接。
连接并不会永久保持，保持时间可以设定。

长连接使用场景：
+ 点对点通讯
+ 请求数量不多
+ 对性能有要求而希望通过建立长连接减少频繁短连接（TCP连接三次握手）的耗时，比如数据库连接

## 3. redis集群的原理

redis集群结合了主从模型（全量镜像）和分片两种技术对数据进行管理的，先单独看这两种技术：

### 主从模型（全量镜像）

+ 主节点支持增删改查操作，主要负责写和同步数据给从节点
+ 只有1个主节点。
+ 可以有多个从节点
+ 从节点可以有自己的从节点。
+ 从节点复制来自主节点的数据，只支持查询操作
+ 从节点先将主节点的信息压入磁盘，再加载到内存
+ 当新的从节点加入集群时，会找到主节点，主节点将全量数据发送给新的从节点

优点：
+ 读写分离
+ 通过增加从节点可以提高并发读的能力

缺点：
+ 主节点的磁盘空间大小是redis集群存储容量的瓶颈
+ 主从关系需要在配置阶段指定（而Zookeeper的平行关系是自主推优的）
+ 从节点的拓展只能提高读效率不能提高写效率
+ 客户端从内存查询数据，所以redis是内存数据库
+ 数据量越大性能消耗越多，应避免在运行期间扩容
+ 主节点故障，集群故障


### 分片（哈希槽）

+ 对象保存到redis前，先经过CRC16哈希到一个指定的Node上
+ 将整个数据库分为16384个槽位Slot，每个数据的键都属于其中一个槽
+ 每个Node被均匀分配了一个槽段，对应着0-16384中的某一个区段。槽被分配时不能重复也不能缺失，否则对象重复存储或无法存储。
+ Node之间互相监听，一旦有Node退出或加入，会按照槽为单位做数据迁移。例如如果Node1分配了0-5640槽段，当Node1退出，0-5640会被均分给其他Node上。

优点：
+ 写操作分摊到多个节点上，提高并发写的能力，扩容容易

缺点：
+ 每个Node承担者互相监听、数据写入读取的操作，任务繁重

### 主从模型+分片

+ 先哈希分逻辑节点
+ 每个逻辑节点内部是主从模型
+ 增加哨兵节点，解决主节点故障问题：
  + 如果哨兵节点认为一个被监视的服务器已经下线时，会向网络中其他哨兵确认，判断该服务器是否真的下线
  + 如果是主服务器下线，那么将对下线主服务器进行自动故障转移：将下线主服务器的某个从服务器提升为新的主服务器，并让其从服务器转为复制新的主服务

这样结合，如果想拓展并发读，就增加从节点；想拓展并发写，就增加主节点；想拓展存储容量，就增加主节点。任何一个主节点或从节点崩溃都不会产生灾难性故障。











