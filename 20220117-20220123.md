# 问题

1. mysql事务隔离的底层实现
2. http的长、短连接以及应用场景
3. redis集群的原理
4. 附加题：关于kafka的全部面试点（你需要尽量了解kafka）

ps：附加题回答不满意不扣钱

# 回答

## 1. mysql事务隔离的底层实现

mysql的事务隔离分四种：


|事务隔离级别 |   脏读   |  不可重复读  |  幻读   |
|:-----:|:------:|:-------:|:-----:|
| 读未提交  |   Y    |    Y    |   Y   |
| 不可重复读 |   N    |    Y    |   Y   |
| 可重复读  |   N    |    N    |   Y   |
|  串行   |   N    |    N    |   N   |


+ 脏读：本次事务中读取到其他事务未提交的数据
+ 不可重复读：本次事务中读取到其他事务已经提交的数据，但是本次事务中再次读取和第一次读取数据不一致
+ 幻读：本地事务中多次读取数据一致，但是出现新插入的数据

Mysql的事务隔离是由存储引擎实现的（Mysql服务器不管理事务），提供了两种事务型的存储引擎：Innodb和NDB Cluster。另外第三方的存储引擎也支持事务：XtraDB、PBXT。

### MVCC 

大多数事务型存储引擎实现都不是简单的行级锁，基于并发性能考虑，一般都实现了多版本并发控制（MVCC）。
以Innodb为例，这里通过简化的MVCC行为来说明实现原理：

Innodb为每个数据行增加两个隐藏列：创建时间、过期时间，用于存储系统版本号。每开始一个新事务，系统版本号自动递增。
事务开始时，系统版本号就是该事务的事务版本号，并且对于事务中相应的执行语句做如下操作：

+ 当事务中执行SELECT语句时：
  + 查找那些创建时间<=当前事务版本号的数据行，这些数据是事务开始前已经存在或当前事务插入或修改的
  + 查找那些过期时间为空或>当前事务版本号的数据行，这些数据是事务开始前还没有被删除的
+ 当事务中执行INSERT语句时：
  + 新插入的行的创建时间设置为当前事务版本号
+ 当事务中执行DELETE语句时：
  + 被删除的行的过期时间设置为当前事务版本号
+ 当事务中执行UPDATE语句时：
  + 插入一行新数据设置其创建时间为当前事务版本号，原来数据的过期时间设置为当前事务版本号

MVCC只在不可重复读和可重复读两个事务隔离级别下工作。因为读未提交总是读取最新的数据，而MVCC只读取符合当前事务版本号的相应数据；串行会对所有读取的行加锁，而MVCC不会。

### 间隙锁

Innodb采用MVCC支持高并发，并通过间隙锁（Next-Key Locking）对索引中的间隙进行锁定，防止幻读出现。


## 2. http的长、短连接以及应用场景

### http短连接

HTTP1.0默认使用短连接。

http客户端和服务端每进行一次HTTP交互，就建立一次连接，任务结束就中断连接。

短连接使用场景：
+ 随机的即时的请求
+ 请求数量多
+ 对资源有限制而希望通过短连接减少长连接的连接数耗费的资源

### http长连接。

HTTP1.1起默认使用长连接。

http客户端和服务端进行HTTP交互只需建立一次连接，并在响应头带上"Connection:keep-alive"表示保持连接而不关闭。
如果客户端再次请求，会继续使用该连接。
连接并不会永久保持，保持时间可以设定。

长连接使用场景：
+ 点对点通讯
+ 请求数量不多
+ 对性能有要求而希望通过建立长连接减少频繁短连接（TCP连接三次握手）的耗时，比如数据库连接






