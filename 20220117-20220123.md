# 问题

1. mysql事务隔离的底层实现
2. http的长、短连接以及应用场景
3. redis集群的原理
4. 附加题：关于kafka的全部面试点（你需要尽量了解kafka）

ps：附加题回答不满意不扣钱

# 回答

## 1. mysql事务隔离的底层实现

mysql的事务隔离分四种：

|事务隔离级别|脏读|不可重复读|幻读|
|--|--|--|--|
|读未提交|Y|Y|Y|
|不可重复读|N|Y|Y|
|可重复读|N|N|Y|
|串行|N|N|N|

+ 脏读：本次事务中读取到其他事务未提交的数据
+ 不可重复读：本次事务中读取到其他事务已经提交的数据，但是本次事务中再次读取和第一次读取数据不一致
+ 幻读：本地事务中多次读取数据一致，但是出现新插入的数据

Mysql的事务隔离是由存储引擎实现的（Mysql服务器不管理事务），提供了两种事务型的存储引擎：Innodb和NDB Cluster。另外第三方的存储引擎也支持事务：XtraDB、PBXT。

### MVCC 

大多数事务型存储引擎实现都不是简单的行级锁，基于并发性能考虑，一般都实现了多版本并发控制（MVCC）。
以Innodb为例，这里通过简化的MVCC行为来说明实现原理：

Innodb为每个数据行增加两个隐藏列：创建时间、过期时间，用于存储系统版本号。每开始一个新事务，系统版本号自动递增。
事务开始时，系统版本号就是该事务的事务版本号，并且对于事务中相应的执行语句做如下操作：

+ 当事务中执行SELECT语句时：
  + 查找那些创建时间<=当前事务版本号的数据行，这些数据是事务开始前已经存在或当前事务插入或修改的
  + 查找那些过期时间为空或>当前事务版本号的数据行，这些数据是事务开始前还没有被删除的
+ 当事务中执行INSERT语句时：
  + 新插入的行的创建时间设置为当前事务版本号
+ 当事务中执行DELETE语句时：
  + 被删除的行的过期时间设置为当前事务版本号
+ 当事务中执行UPDATE语句时：
  + 插入一行新数据设置其创建时间为当前事务版本号，原来数据的过期时间设置为当前事务版本号

MVCC只在不可重复读和可重复读两个事务隔离级别下工作。因为读未提交总是读取最新的数据，而MVCC只读取符合当前事务版本号的相应数据；串行会对所有读取的行加锁，而MVCC不会。

### 间隙锁

Innodb采用MVCC支持高并发，并通过间隙锁（Next-Key Locking）对索引中的间隙进行锁定，防止幻读出现。



