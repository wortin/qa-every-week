# 问题

1. tcp、http协议的实现方式和配置参数
2. socket协议的实现方式和配置参数
3. kafka实现原理

注：题目都很大，每一题要完全吃透怕一周时间根本不够，所以讲一个总体和重要的。
因为过年事情比较多，也有身体原因，这个题目一直拖到20220213才开始草草回答。

# 回答

## 1. tcp、http协议的实现方式和配置参数

关于这个问题，我阅读了《HTTP权威指南》，回答这个问题主要是本书的第4章“连接管理”。

### HTTP连接（HTTPS）的分层结构

1. 应用层：HTTP协议
2. 安全层：TLS/SLL
3. 传输层：TCP协议
4. 网络层：IP协议
5. 数据链路层：网络特有的链路接口
6. 物理层：物理网络硬件

所以，HTTP通信由TCP/IP承载，TCP/IP是全球计算机及网络设备都在使用的一种常见的分组交换网络分层协议集，一旦连接建立，报文就不会丢失、受损、失序。因为TCP协议具有下面3个特点：
1. 无差错的数据传输
2. 按序传输
3. 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

### HTTP、TCP、IP协议实现过程

一个浏览器和服务器之间的HTTP事务（指一次HTTP请求和响应）具有如下步骤：
1. 浏览器解析 http://wortin.com/index.html 的主机名wortin.com
2. 浏览器查询主机名wortin.com对应的IP地址150.158.133.76
3. 浏览器获得端口号80
4. 浏览器发起到150.158.133.76:80的连接
5. 浏览器发送一条HTTP GET报文
6. 浏览器从服务器读取响应报文
7. 浏览器关闭连接

其中，第5步，HTTP会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流之后，会将数据流砍成小数据块，称为TCP段，并将段封装在IP分组中，通过因特网进行传输。

IP分组格式：
1. IP分组首部（20字节）：包括源IP地址、目的IP地址、长度和其他标记等
2. TCP段首部（20字节）：包括TCP源端口号、目的端口号、TCP控制标记、数据排序和完整性检查数字值等
3. TCP数据块：数据内容

其中，第4步到第7步，浏览器和服务器应用在编程时，通过调用TCP套接字接口（Socket API）实现。Socket API最初是由Unix操作系统开发的，现在几乎所有操作系统和语言中都有支持。
Socket API允许用户创建TCP的端点数据结构，将这些端点和远程服务器的TCP端点进行连接，并对数据流进行读写，隐藏了所有底层网络协议的握手、分段、重装等细节。

TCP连接常见Socket API:
+ 创建套接字：s = socket(<parameters>)
+ 绑定源IP和端口：bind(s, <local IP:port>)
+ 创建远程连接：connect(s, <remote IP:port>)
+ 接受连接：listen(s, ...)
+ 等待建立一条到本地端口的连接：s2 = accept(s)
+ 读取数据到缓冲区：n = read(s, buffer, n)
+ 从缓冲区写入数据：n = write(s, buffer, n)
+ 完全关闭TCP连接：close(s)
+ 只关闭TCP连接的输入或输出端：shutdown(s, <side>)

所以，第4步到第7步，从套接字的角度可以细分为如下步骤：
+ --- 服务器上的应用程序启动时
+ 服务端应用程序创建套接字 s = socket() 并绑定源IP和端口 bind(s, 150.158.133.76:80)
+ 服务端应用程序接受连接 listen(s, ...)
+ 服务端应用程序等待连接 s2 = accept(s)
+ --- 浏览器开始发送请求
+ 浏览器获取源IP和端口162.1.3.11:8080
+ 浏览器创建套接字 s = socket() 并绑定源IP和端口 bind(s, 162.1.3.11:8080)
+ 浏览器连接到服务器 connect(s, 150.158.133.76:80)
+ --- 服务器接收到来自浏览器的连接
+ 服务器通知应用程序有连接到来
+ 服务端应用程序开始读取请求 read
+ 服务端应用程序处理HTTP请求
+ 服务端应用程序回送HTTP响应 write
+ 服务端应用程序关闭连接 close
+ --- 服务器通知应用程序有连接到来时
+ 浏览器感知到连接成功
+ 浏览器发送HTTP请求 write
+ 浏览器等待HTTP响应 read
+ 浏览器处理响应
+ 浏览器关闭连接 close

### TCP连接的性能考虑

HTTP事务的时延来自：
1. DNS查询：如果最近没有某个URI访问，则需要通过DNS解析系统将URI中的主机名转化成一个IP。可能需要花费数10s
2. 建立TCP连接：客户端向服务端发送TCP连接请求，并等待请求接受应答。通常花费1-2s，但是如果事务超过数百个，耗时将快速叠加
3. 客户端发送请求报文、服务端处理报文、服务端回送报文

影响时延的因素取决于：
1. 硬件速度
2. 网络和服务器负载
3. 请求和响应报文的尺寸
4. 客户端和服务端的距离
5. TCP技术复杂性

对HTTP程序员产生影响的TCP时延因素：
1. TCP连接建立握手: 客户端发送SYN / 服务端回应 SYN + ACK / 客户端确认 ACK；解决方案是持久连接
2. 延迟确认：每个TCP请求需要返回一个响应来确认这个请求数据无误，否则需要重发，为了充分利用网络，确认报文会在稍后的数据报文中捎带发送；解决方案是调整或禁止确认延迟算法
3. TCP慢启动拥塞控制：新的TCP连接发送1个IP分组被确认后才能再发送2个IP分组，确认后再发送4个，依次类推；解决方案是持久连接
4. 数据聚集的Nagle算法：尽可能将IP分组的数据块塞满再发送，但可能长时间攒不够数据块或者和延迟确认交互存在问题；解决方案是TCP_NODELAY禁用Nagle算法
5. TIME_WAIT时延和端口耗尽: TIME_WAIT防止在一段时间内重复创建同IP端口的TCP连接，在基准测试时这限制了可用的连接测试值组合；解决方案是增加机器数或虚拟IP

### HTTP连接的处理

+ 串行事务：串行发送HTTP请求（每次发送都需要新建和关闭一个新的TCP连接）
+ 并行连接：在多个TCP连接中并发地发送HTTP请求
+ 持久连接：在一个TCP连接中串行发送HTTP请求
+ 管道化连接：在一个TCP连接中一次性发送多个HTTP请求，而不需要等待前一个请求响应返回再发送下一个

#### 并行连接

+ 并行连接可能提高页面加载速度：因为将串行的时延叠加了
+ 并行连接不一定更快：如果网络带宽不足，多个TCP连接竞争带宽；另外多个TCP消耗内存资源，一般浏览器会限制并行连接数量不超过4个
+ 并行连接可能让人感觉更快：图片的渐进式加载

#### 持久连接

+ 持久连接解决了新建和关闭连接的时延和TCP慢启动的时延 
+ HTTP/v1.0+keep alive
  + 一般流程：
    1. 客户端发送包含Connection: Keep-Alive的请求，希望将连接保持在打开状态
    2. 服务端愿意保持打开状态，则响应中包含Connection: Keep-Alive；否则不包含该首部
    3. 客户端收到响应如果不包含Connection: Keep-Alive，则认为服务端不支持持久连接，将关闭连接
  + 首部包含Connection: Keep-Alive只是希望保持持久连接，事实上客户端和服务端可以在任何时刻关闭连接，并随意限制持久连接所能处理的事务数量
  + 可以在Keep-Alive首部配置参数：
    + timeout: 出现在响应中，表示服务器希望将连接保持在活跃状态的时间，并不是一个承诺值（单位是秒）
    + max：出现在响应中，表示服务器希望为多少个事务保持次连接的活跃状态，并不是一个承诺值
  + 不是默认支持持久连接，必须在首部中包含Connection: Keep-Alive
  + 代理在转发报文时，必须删除报文中Connection首部中出现的首部字段和Connection首部自身
+ HTTP/v1.1+persistent
  + 默认支持持久连接
  + 要在事务结束后关闭连接，必须在报文中显示的增加Connection: close首部
  + 客户端和服务端可以随时关闭空闲连接，不发送Connection: close首部并不意味着连接将永远保持

#### 持久连接+并行连接=高效的连接方式

并行连接的优点：叠加串行连接的时延
并行连接的缺点：需要新建关闭多个TCP连接，新TCP连接存在慢启动，竞争带宽，占用内存，并行连接数数量存在限制
持久连接的优点：减少新建连接和慢启动的时延
持久连接的缺点：空闲连接占用内存

很多浏览器会打开少量并行连接，并且每个都是持久连接。

#### 管道化连接

+ HTTP/v1.1允许选用管道化连接
+ 管道化连接必须基于持久连接
+ 在响应达到之前，可以将多条请求放入队列，当第一条请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了


## 2. socket协议的实现方式和配置参数

Socket是网络中进程通讯的一种方式。
Socket起源于Unix，而 Unix/Linux 基本哲学之一就是一切皆文件，都可以用 打开open –> 读写write/read –> 关闭close 的模式来操作。

TCP套接字接口见问题1。

### TCP三次握手建立连接

+ 服务端：socket -> bind -> listen
+ 客户端：socket -> bind
+ 客户端：connect -> 发送 SYN K 请求 -> connect阻塞
+ 服务端：accept -> 接收到 SYN K 请求，发送 SYN J / ACK K+1 请求 -> accept阻塞
+ 客户端：收到SYN J / ACK K+1，发送 ACK J+1 -> connect返回
+ 服务端：收到ACK J+1 -> accept返回
至此，连接建立

### TCP四次挥手关闭连接

+ 客户端：close -> 发送 FIN M 请求
+ 服务端：收到FIN M，发送 ACK M+1
+ 服务端：close -> 发送 FIN N 请求
+ 客户端：收到FIN N，发送 ACK N+1
至此，连接关闭

## 3. kafka实现原理

+ broker：由多个kafka server组成的集群，存储消息
  + 可以通过指定时间段来保存消息，节省broker存储空间
  + 当机器负载满时，通过扩容，将消息以partition为单位重新均匀分配
+ topic：消息分类方式，不同主题的消息都存储在broker中
  + 每个topic可以分成多个partition，每个partition由多个消息组成
  + 每个消息被标志了一个递增序列号代表进来的先后顺序，并按顺序存储在partition中
  + partition被均匀分配到集群server中
+ producer：往broker中某个topic里面生产数据，被路由到指定partition，消息会通过分配策略append到指定partition的末尾
+ consumer：从broker中某个topic里面获取数据，被路由到指定partition，通过id（称为offset）指定从哪个位置开始消费消息
  + 消息被消费后，不会被删除
  + 通过consumer group将队列和发布订阅两种模式统一处理：
    + 每个consumer将自己标记consumer group名称
    + 系统会将consumer group按名称分组，将消息复制并分发给所有分组，每个分组只有一个consumer能消费这条消息。
    + 当所有consumer的consumer group相同时，就是队列模式
    + 当所有consumer的consumer group不同时，就是发布/订阅模式
  + 多个consumer并发消费时，容易导致消息乱序，通过限制消费者为同步，可以保证消息有序，但降低了并发性
  + consumer采用pull方式
    + 可配置化参数保证当存在数据并且数据量达到一定量的时候，consumer端才进行pull操作，否则一直处于block
    + 采用整数值consumer position来记录单个分区的消费状态，并且单个分区单个消息只能被consumer group内的一个consumer消费
    + 消费完成，broker收到确认，position指向下次消费的offset
  
  