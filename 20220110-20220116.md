# 问题

1. 进程和线程的区别是什么？哪个效率高，为什么？
2. 死锁的条件是什么？如何解决？
3. java的基本数据类型和字节数是什么？
4. mysql的索引结构、特点是什么？为什么使用索引？
5. 聚集索引和非聚集索引是什么？


# 回答

## 1. 进程和线程的区别是什么？哪个效率高，为什么？

区别：

+ 基本概念不同：进程是计算机系统分配资源的基本单位；线程是处理器调度的基本单位。
+ 大小关系不同：一个应用程序包含至少一个进程；一个进程包含至少一个线程。
+ 资源占用不同：两个进程一般具有独立的内存等资源；而两个线程可以共享内存等资源。
+ 调度成本不同：进程上下文切换成本大；线程上下文切换成本小。
+ 交互方式不同：两个进程间协作有进程间共享内存、进程间同步、守护进程等技术；两个线程间协作有锁、通道等技术。
+ 影响程度不同：一个进程崩溃一般不会影响其他进程或整个计算机系统；一个线程崩溃往往导致整个进程崩溃。

线程比进程效率高，因为它执行开销小，上下文切换成本低，能更高效地利用处理器。

## 2. 死锁的条件是什么？如何解决？

死锁的四个必要条件（发生死锁时，必然存在下面的情况）：

+ 互斥条件：某一资源在一段时间内仅被一个线程占用，如果此时还有其他线程请求该资源，则请求线程只能等待，除非占用资源的线程用毕释放。
+ 请求和保持条件：一个线程已经占用某个资源，又需要请求占用另一个资源，但该资源已被其他资源占用，所以被阻塞等待，同时对已经占用的资源保持不放。
+ 不剥夺条件：一个线程已经占用某个资源，在未完成前，不能被剥夺。
+ 环路等待条件：存在一个线程资源环形链，即P0线程正在等待P1线程占用的资源，P1线程正在等待P2线程占用的资源，...，Pn线程正在等待P0线程占用的资源。

解决死锁的方式：

+ 打破四个必要条件任意一个就可以有效预防死锁：
    + 打破互斥条件：给每个线程分配一个自己的资源，不需要抢资源。
    + 打破请求和保持条件：线程执行前，申请好所有需要的资源，满足则运行，否则就等待；或者线程执行时，逐步释放掉用完的资源，不必等全部执行完在释放。
    + 打破不剥夺条件：如果线程在占用某个资源又请求另一资源而不得时，释放已经占用的资源，在阻塞等待。
    + 打破环路等待条件：定义线程资源的线性执行顺序。例如给资源编号，当一个线程占用编号i的资源时，如果再申请资源只能申请编号大于i的资源。
+ 允许死锁发生，检测死锁发生后，解除死锁：
    + 剥夺资源：从线程中剥夺足够的资源给死锁线程
    + 撤销线程：撤销死锁线程，甚至重启应用
    

## 3. java的基本数据类型和字节数是什么？

+ 浮点类型：float(4)  double(8)
+ 整数类型：byte(1) short(2) int(4) long(8)
+ 布尔类型：boolean(1)
+ 字符类型：char(2)

## 4. mysql的索引结构、特点是什么？为什么使用索引？

mysql的索引结构主要有B+Tree索引和Hash索引。

B+Tree结构的索引的特点是：

+ 是 Innodb 和 Myisam 存储引擎模式的默认索引结构
+ 基于B+Tree实现，查询性能是O(h*logn)，其中h是树高，n是一个节点的索引数
+ 适合范围查找、排序操作场景，例如>、<=
+ 不适合否定条件查找，例如not in、<>
+ 平衡性好，就算大量数据或自增型数据插入，仍然能有较小的树高，提高查询效率
+ 非叶子节点只存储索引，叶子节点存储索引和数据，一个节点的大小等于一个页，只需一次I/O就可以载入多条索引，提高查询效率
+ 叶子节点具有访问相邻叶子节点的指针，提高了区间查询效率


Hash索引的特点是：

+ 是 Memory 存储引擎的默认索引结构
+ 基于Hash表实现，查询性能是O(1)
+ 适合精确匹配的查找，例如=、<=>、in
+ 不适合范围查找、排序，不适合为区分度小的列建立索引，例如性别字段
+ hash冲突时，会将具有相同hash值的数据存在同一个链表中
+ Innodb引擎如果注意到某些索引被频繁使用时，会在B-Tree索引上创建Hash索引，称为自适应Hash索引，以提供查询效率
+ 可以通过增加一个字段存储hash值，对该字段建立索引，从而实现伪哈希索引

使用索引是因为：

+ 直接原因是为了提高查询效率
+ 本质原因是减少磁盘I/O读取次数

## 5. 聚集索引和非聚集索引是什么？

聚集（Clustered）索引也称聚簇索引。定义是数据行的物理顺序与索引列值（一般指主键列）的逻辑顺序相同，一个表只能拥有一个聚集索引。

+ 适用场景：当查询以聚集索引为排序依据、区间查询、返回大量结果集时适合使用聚集索引。
+ 缺点：聚集索引会降低插入和更新操作的性能。

非聚焦（Unclustered）索引的定义是数据行的物理顺序与索引列值的逻辑顺序不同，即不是聚集索引的索引都是非聚集索引。

+ 适用场景：查询返回较少数据量、某字段的数据唯一性比较高、数据更新性能敏感时。
+ 缺点：相对聚集索引查询效率低


